Now that I'm able to use threaded code, I need to think about how to transform LISP into something that resembles Forth

I'll suppose I have this function:
	(define 'f (lambda (x y) (* 2 (+ x y))))
The answer is simple, looking at it as a human:
	: f + 2 *
Now let's suppose the function's result depends on the arguments being in the right order:
	(define 'f (lambda (x y) (/ 2 (- x y))))
This would become:
	: f - 2 swap / ;
This is an acceptable result, but how would the compiler handle the arguments automatically?
As a human, I can easily visualize changes to the stack with each function call.
How can I automate this, and how would it translate into threaded code?

I could see functions for fetching each argument. For example:
fetch1:
	popq	%rdi
	pushq	(%rsp)
	pushq	%rdi
	ret
fetch2:
	popq	%rdi
	pushq	8(%rsp)
	pushq	%rdi
	ret

This could be generalized, maybe like so:
pick:
	popq	%rdi
	popq	%rax
	pushq	(%rsp,%rax,8)
	pushq	%rdi
	ret
Better yet, without push or pop:
pick:
	movq	8(%rsp), %rax
	addq	$2, %rax
	movq	(%rsp,%rax,8), %rax
	movq	%rax, 8(%rsp)
	ret

Now the issue is, how do I push literal values to the stack with only function calls?
I can't (or shouldn't) just make a function for every literal I might want to push.
After all, real languages that already exist have limits to the number of arguments they can take.

If I had a solution to this, I could translate
	(define 'f (lambda (x y) (/ 2 (- x y))))
into
	# eval (/ 2 (- x y))
	call	push2 # I will need to figure out how to deal with these kinds of literals as well
	# eval (- x y) :
	# (
	call	fetch1
	call	fetch2
	call	sub
	# )
	call	div
	call	return2

I need another stack...
I could try addressing arguments relative to %rbp.
If functions began by updating %rbp, maybe a function arg1 could be
arg1:
	# (%rbp) would be previous base pointer
	# 8(%rbp) would be the return address
	popq	%rdi
	pushq	16(%rbp) # arg1
	pushq	%rdi
	ret

Then the function would be
	#(
	{push 2 somehow}
	#(
	call	arg1
	call	arg2
	call	sub
	#)
	call	div
	#)
	call	return

To avoid the headache of literals for the moment, I'm going to reflect on what a function would look like in memory.
Ideally, it would be just a list of addresses of functions to call.
I could have null mean that the next address is a literal to be pushed...
Maybe it would look like this:

funcall:
	pushq	%rbp
	movq	%rsp, %rbp
	movq	8(%rsp), %rax
	.funcall_loop:
	movq	(%rax), %rcx # Moving an address
	cmpq	$0, %rcx
	jz	.funcall_pushliteral
	call	*%rcx
	addq	$8, %rax # Next address
	jmp	.funcall_l
	.funcall_pushliteral:
	cmpq	$0, 8(%rax)
	jz	.funcall_exit # Never two 0x0 in a row
	pushq	8(%rax)
	addq	$16, %rax
	jmp	.funcall_loop
	.funcall_exit:
	movq	%rbp, %rsp
	popq	%rbp

(I've ignored return values for now. The relevant section would be after .funcall_exit.)
Under this scheme, the top of the stack is the address to the "function".
This means the argument accessing functions would need to skip another 8 bytes on the stack.
However, this could allow for easy recursion in the form of MJLisp's currect # (self) operator.
(Note to self: @ would have made more sense since it looks like a loop)

Another idea: The way retrieving arguments is handled could be similar to the way literals are handled.
So this function
	(define 'f (lambda (x y) (/ 2 (- x y))))
might look like this in memory:
+0:	0x0			{push literal}
+8:	0xDEADBEEFDEADBEE1	[2]
+16:	0x1			{push argument}
+24:	0x1			{first argument}
#	(Note: 0x0 would then be the function itself)
+32:	0x1			{push argument}
+40:	0x2			{second argument}
+48:	0xDEADBEEFDEADBEE2	[sub]
+56:	0xDEADBEEFDEADBEE3	[div]
+64:	0xDEADBEEFDEADBEE4	[return2]

Of course, I could maybe use 4-byte chunks to save space.
I'll rewrite funcall with argument pushing included

funcall:
	pushq	%rbp
	movq	%rsp, %rbp
	movq	8(%rsp), %rax # Load the pointer to the function
	xorq	%rcx, %rcx # Set the counter to 0
	.funcall_loop
	movq	(%rax,%rcx,8), %rdx # Load the next address
	cmpq	$0, %rdx
	jz	.funcall_pushq
	cmpq	$1, %rdx
	je	.funcall_pusharg
	call	*%rdx
	jmp	.funcall_loop
	.funcall_pushq:
	incq	%rcx
	movq	(%rax,%rcx,8), %rdx # Load the literal to be pushed
	cmpq	$0, %rdx
	jz	.funcall_exit # If null, exit (so 0x0 0x0 denotes the end of the function)
	pushq	%rdx
	incq	%rcx
	jmp	.funcall_loop
	.funcall_pusharg:
	incq	%rcx
	movq	(%rax,%rcx,8), %rdx
	addq	$2, %rdx
	pushq	(%rbp,%rdx,8)
	incq	%rcx
	jmp	.funcall_loop:
	.funcall_exit
	# At this point there must only be one thing on the stack
	popq	%rdx # Take that thing off the stack
	movq	%rbp, %rsp # Reset the stack
	popq	%rbp
	popq	%rdi # Preserve the return address
	pushq	%rdx
	pushq	%rdi # Restore the return address
	ret

There are three remaining issues.

The most obvious issue is with returning the value left on the stack. This will vary by number of arguments.
How many times do we call drop before we leave the return value on the stack?
One idea I have for this is to leave a 0x0 on the stack and drop up to it. However, this is a really sloppy solution.
Perhaps the best option is to make the first 8 bytes of a function represent the number of arguments

The bigger issue with this approach (as a whole) is branching. How might an 'if' or 'cond' be implemented?
In Forth, if works like this (to print zero if the top of the stack is zero):
: zero 0 = if ." zero" else ." non-zero" then cr ;
However, this is a compile-only feature.
This could maybe be implemented as a flag which decides whether to go through with function calls.
I think that solution is fairly sloppy.

The last issue is that calling a function "destroys" rax, rcx, rdx, etc. They just need to be preserved somehow.

Round 3 will try to address issues 1 and 3.
funcall:
	pushq	%rbp
	movq	%rsp, %rbp
	movq	8(%rsp), %rax # Load the pointer to the function
	movq	$1, %rcx # Set the counter to 1 (0 is # of args)
	.funcall_loop
	movq	(%rax,%rcx,8), %rdx # Load the next address
	cmpq	$0, %rdx
	jz	.funcall_pushq
	cmpq	$1, %rdx
	je	.funcall_pusharg
	movq	%rax, %r8
	movq	%rcx, %r9
	call	*%rdx
	movq	%r9, %rcx
	movq	%r8, %rax
	jmp	.funcall_loop
	.funcall_pushq:
	incq	%rcx
	movq	(%rax,%rcx,8), %rdx # Load the literal to be pushed
	cmpq	$0, %rdx
	jz	.funcall_exit # If null, exit (so 0x0 0x0 denotes the end of the function)
	pushq	%rdx
	incq	%rcx
	jmp	.funcall_loop
	.funcall_pusharg:
	incq	%rcx
	movq	(%rax,%rcx,8), %rdx
	addq	$2, %rdx
	pushq	(%rbp,%rdx,8)
	incq	%rcx
	jmp	.funcall_loop:
	.funcall_exit
	# At this point there must only be one thing on the stack
	popq	%rdx # Take that thing off the stack
	movq	%rbp, %rsp # Reset the stack
	popq	%rbp
	popq	%rdi # Preserve the return address
	movq	(%rax), %rcx # Store the number of variables
	negq	%rcx
	incq	%rcx # +1 for function address left on stack
	.funcall_dropargs:
	call	drop
	decq	%rcx
	cmpq	$0, %rcx
	jz	.funcall_dropargs
	pushq	%rdx
	pushq	%rdi # Restore the return address
	ret

Problem 2 can be solved later.
Note: %r8 and %r9 are expected to be unused by any handwritten assembly.
This is unreliable and should be changed.

Another problem: user defined functions need to be called using funcall
This can be solved later with the addition of a few lines.

During the attempted writing of the function below, I realized that I need a way to tell when something is a function.
So, the function's first 8 bytes will be the negative of the number of args, so that it can be checked easily.
A function with no arguments looks like a list, though, so that will need to be worked with in the future

lambda_size: # Predicts the size of the compiled body
	xorq	%rcx, %rcx
	call	over
	.lambda_size_loop:
	call	zornil
	cmpq	$1, %rax
	je	.lambda_size_ret
	call	dup
	call	car
	popq	%rax
	call	cdr
	cmpq	$0, (%rax)
	jgt	.lambda_size_flag
	jz	.lambda_size_list
	addq	$8, %rcx
	jmp	.lambda_size_loop
	.lambda_size_flag:
	addq	$16, %rcx
	jmp	.lambda_size_loop
	.lambda_size_list:
	pushq	%rcx
	pushq	%rax
	call	lambda_size
	popq	%rcx
	addq	%rcx, (%rsp)
	popq	%rcx
	jmp	.lambda_size_loop
	.lambda_size_ret:
	call	drop
	movq	%rcx, 8(%rsp)
	ret

I would write lambda now, but I can't test lambda_size until I implement read, so that's probably next.
Actually, cancel that, but it will only be able to be tested with literals.

Now that I think of it, a lot of the issues with register preservation wouldn't be a problem if I didn't call other functions.
What I mean is, I can replace "call dup" with "push (%rsp)" and "call drop" with "addq $8, %rsp" or "popq 8(%rsp)"
This would be more efficient, but could reduce the readability of the assembly (if no comments were added).
For places where a function call is required, I could impose my own calling convention to keep things standard,
e.g. r14 and r15 are reserved for use by funcall to preserve %rax and %rcx around call *%rdx

Anyway, now for lambda. To convert Lisp into RPN, I wrote this function in Common Lisp:
(defun rpn (l) (if (atom l) (cons l) (reduce #'append (append (mapcar #'rpn (cdr l)) (cons (rpn (car l)) nil)))))

My thought process was like this:
I need to move the function to the back, so (append (cdr l) (cons (car l) nil)) would work.
However, arguments (and even the function) could be expressions, so (append (mapcar #'rpn (cdr l)) (cons (rpn (car l)) nil)) would work
Then it needs to handle atoms, so (if (atom l) l (append (mapcar #'rpn (cdr l)) (cons (rpn (car l)) nil))) would work
Then it needs to be flattened, and this resulted in the final product above.

On its own, flatten can be defined by (defun flatten (l) (if (atom l) (cons l nil) (reduce #'append (mapcar #'flatten l))))

Now I just need figure out how to translate rpn into assembly

One thing that would make it easier would be to take the functional programming techniques out of it.
If I can rewrite rpn using loop (and recursion), the translation will be much easier.

Here's a candidate that's almost good:
(defun rpn (l) (if (atom l) (cons l nil) (append (rpn (cdr l)) (rpn (car l)))))
But, it leaves a few NILs in the list, one before any nested expression's translation.
I suspect that a small modification would fix this. The other option is remove-if #'null.
Another issue is that it reverses the arguments.
A two-function solution could work for this.

Here's a candidate that solves the NIL problem:
(defun rpn (l) (cond ((null l) nil) ((atom l) (cons l nil)) (t (append (rpn (cdr l)) (rpn (car l))))))

Here's a perfect two-function solution:
(defun rpn (l) (cond ((null l) nil) ((atom l) (cons l nil)) (t (append (maprpn (cdr l)) (rpn (car l))))))
(defun maprpn (l) (if l (append (rpn (car l)) (maprpn (cdr l))) nil))

This is much easier to translate.
